/*
 * Copyright (C) 2020, Donald McLean. All rights reserved.
 *
 * This program and the accompanying materials are licensed under
 * the terms of the GNU General Public License version 3.0
 * as published by the Free Software Foundation.
 */
package org.primitive.ml

import net.liftweb.actor.LiftActor
import net.liftweb.common.Full
import org.slf4j.Logger

import scala.xml.Node

/**
  * The basic unit of functionality in the EFL. Modules are "start"ed at program startup and "stop"ed
  * at program termination.
  */
trait Module {

  var name: String = "unnamed"
  def setName(data: Node): Unit ={
    data.attribute("name").foreach(a => name = a.toString())
  }

  /**
    * Called by the ModuleLoader at program startup so that the module can initialize its functional components
    * and register its services.
    *
    * @param context - the specific EFLContext within which this module will be operating.
    * @param data - XML giving module specific initialization and configuration details.
    */
  def start(context: Context, data: Node): OpResult[Unit]

  /**
    * Called at context shutdown (may or may not be during program shutdown) so
    * that modules will be able to write out unsaved data, free up resources, etc.
    *
    * @param context - the EFLContext this module has been running in.
    */
  def stop(context: Context): Unit

  /**
    * Called by a context that wants to import this module from a parent module.
    *
    * @param context - the context that wishes to use this module's services
    */
  def addContext(context: Context): Unit

  /**
    * Called by an importing context at shutdown
    *
    * @param context - the context that no longer needs this module's services
    */
  def removeContext(context: Context): Unit
}

class OpResult[T] extends scala.AnyRef {
  /**
   * An incomplete operation is a future
   */
  private var satisfied: Boolean = false

  /**
   * If we have reached any non-fatal condition (success or non-fatal error)
   */
  private var canContinue: Boolean = false

  private var data: List[T] = Nil
  private var messages: List[String] = Nil
  private var failures: List[Exception] = Nil

  def this(continue: Boolean, data: List[T] = Nil, messages: List[String] = Nil, failures: List[Exception] = Nil) = {
    this()

    satisfied = true
    canContinue = continue
    this.data = data
    this.messages = messages
    this.failures = failures
  }

  override def toString: String =
    "OpResult[" + hashCode() +
    "](satisfied = " + satisfied +
    ", continue = " + canContinue +
    ", data records = " + data.size + ")"

  /**
   * In a group of operations, the software should continue performing
   * operations from the group as long as continue remains true
 *
   * @return true if the system state resulting from the operation is continuable
   */
  def continue: Option[Boolean] = if(satisfied) Some(canContinue) else None

  /**
   * Caller is expecting that the operation is satisfied and the result was
   * not a failure
   * @return true if operation is complete and not a failure
   */
  def satisfiedContinue: Boolean = satisfied && canContinue

  /**
   * Caller is expecting that the operation is satisfied and the result was
   * not a failure
   * @return true if operation is NOT satisfied or has failed
   */
  def unsatisfiedFailure: Boolean = !(satisfied && canContinue)

  /**
   * Returns information/warning/error messages generated by the operation, or Nil
   * @return List[String] zero or more messages
   */
  def getMessages: Option[List[String]] = if (satisfied) Some(messages) else None

  /**
   * Returns any data that was produced
    * @return List[AnyRef] zero or more result objects
   */
  def getData: Option[List[T]] = if(satisfied) Some(data) else None

  /**
   * If the operation was complete, successful, and returned one value, we return Some
   * otherwise, None
   * @return Some[T] if there is exactly one datum
   */
  def singularOption: Option[T] = {
    if (satisfied && canContinue && data.size == 1) Some(data.head)
    else None
  }

  def complete(subResult: OpResult[T]): Unit = {
    if (subResult.satisfied) {
      satisfied = true
      canContinue = subResult.canContinue
      data = subResult.data
      messages = subResult.messages
      failures = subResult.failures
    }
  }

  def addResult(r: T): Unit = {
    data = r::data
  }

  def setResult(r: T): Unit = {
    data = List[T](r)
    canContinue = true
    satisfied = true
  }

  def setResult(l: List[T]): Unit = {
    data = l
    canContinue = true
    satisfied = true
  }

  def success(): Unit = {
    canContinue = true
    satisfied = true
  }

  def addMessage(message: String): Unit = {
    messages = message::messages
  }

  def fail(message: String): Unit = {
    messages = message::messages
    canContinue = false
    satisfied = true
  }

  def fail(exception: Exception): Unit = {
    failures = exception::failures
    canContinue = false
    satisfied = true
  }

  def fail(subResult: OpResult[_]): Unit = {
    messages = subResult.messages
    failures = subResult.failures
    canContinue = false
    satisfied = true
  }

  /**
   * Combines results from two operations into a single result
   * @param right the result to be combined with "this"
   * @return the combined result
   */
  def merge(right: OpResult[T]): OpResult[T] = OpResult.softMerge(this, right)

  /**
   * Expecting exactly one value and get it or None
   * @return
   */
  def waitForSingle(): Option[T] = {
    while(! satisfied) {
      Thread.sleep(10)
    }

    if (canContinue && data.length == 1) Some(data.head)
    else None
  }

  /**
   * Expecting exactly one value and get it or None
   * @return
   */
  def waitForSingle(timeout: Long): Option[T] = {
    val start = System.currentTimeMillis()
    while(! satisfied) {
      Thread.sleep(10)

      val now = System.currentTimeMillis()
      if (now > start + timeout) return None // timeout expired
    }

    if (canContinue && data.length == 1) Some(data.head)
    else None
  }

  /**
   * Expecting exactly one value and get it or None
   * @return
   */
  def waitForSingle(logger: Logger): Option[T] = {
    logger.trace("[OpResult.waitForSingle] enter, satisfied: {}", satisfied)
    while(! satisfied) {
      Thread.sleep(10)
      logger.trace("[OpResult.waitForSingle] Waiting....")
    }

    if (canContinue && data.length == 1) Some(data.head)
    else None
  }

  /**
   * Expecting exactly one value and get it or None
   * @return
   */
  def waitForSingle(logger: Logger, timeout: Long): Option[T] = {
    logger.trace("[OpResult.waitForSingle] enter, satisfied: {}", satisfied)

    val start = System.currentTimeMillis()
    while(! satisfied) {
      Thread.sleep(10)

      val now = System.currentTimeMillis()
      logger.info("[OpResult.waitForSingle] waited: {}", (now - start))
      if (now > start + timeout) return None // timeout expired
    }

    if (canContinue && data.length == 1) Some(data.head)
    else None
  }

  def waitFor(): Option[List[T]] = {
    while(! satisfied) {
      Thread.sleep(10)

      if (canContinue) {
        return None
      }
    }

    Some(data)
  }
}

object OpResult {
  def simpleSuccess[T](): OpResult[T] = {
    new OpResult[T](true)
  }

  def successWithMessages[T](messages: List[String]): OpResult[T] = {
    new OpResult[T](true, Nil, messages)
  }

  def successWithDatum[T](datum: T, messages: List[String] = Nil): OpResult[T] = {
    new OpResult[T](true, List[T](datum), messages)
  }

  def successWithData[T](data: List[T], messages: List[String] = Nil): OpResult[T] = {
    new OpResult[T](true, data, messages)
  }

  def failure[T](failure: Exception): OpResult[T] = {
    new OpResult[T](false, Nil, Nil, List[Exception](failure))
  }

  def failure[T](message: String): OpResult[T] = {
    new OpResult[T](false, Nil, List[String](message))
  }

  def failure[T](messages: List[String]): OpResult[T] = {
    new OpResult[T](false, Nil, messages)
  }

  def failure[T](source: OpResult[_]): OpResult[T] = {
    new OpResult[T](false, Nil, source.messages, source.failures)
  }

  def future[T](): OpResult[T] = {
    val r = new OpResult[T]()
    r.satisfied = false
    r
  }

  def softMerge[T](left: OpResult[T], right: OpResult[T]): OpResult[T] = {
    if (left == null) right
    else if (right == null) left
    else if (right.satisfied && left.satisfied) {
      val continue = left.canContinue && right.canContinue
      val messages = left.messages ++ right.messages
      val data = left.data ++ right.data

      if (continue) {
        if (messages.isEmpty && data.isEmpty) simpleSuccess()
        else if (data.isEmpty) successWithMessages(messages)
        else successWithData(data, messages)
      } else {
        failure(messages) // both are failures, so no data
      }
    } else {
      //TODO: merge with one or more unsatisfied futures
      null
    }
  }
}

//class OpFuture[T] extends OpResult {
//  private var satisfied: Boolean = false
//  private var aborted: Boolean = false
//  private var result: T = _
//  private var messages: List[String] = Nil
//  private var failures: List[Exception] = Nil
//
//  def setResult(r: T): Unit = {
//    result = r
//    satisfied = true
//  }
//
//  def addMessage(message: String): Unit = {
//    messages = message::messages
//  }
//
//  def fail(message: String): Unit = {
//    messages = message::messages
//    aborted = true
//  }
//
//  def fail(exception: Exception): Unit = {
//    failures = exception::failures
//    aborted = true
//  }
//
//  override def continue: Boolean = satisfied || !aborted
//
//  def getResult: T = result
//
//  override def getMessages: List[String] = messages
//
//  /**
//   * Returns any data that was produced
//   *
//   * @return List[AnyRef] zero or more result objects
//   */
//  override def getData: List[AnyRef] = {
//    waitFor()
//    List[AnyRef](result)
//  }
//
//  override def merge(right: OpResult): OpResult = OpFailure("Not implemented [OpFuture.merge]")
//
//  def isComplete: Boolean = satisfied
//  def isSuccess: Boolean = !aborted
//
//  def waitFor(): Option[T] = {
//    while(! satisfied) {
//      Thread.sleep(10)
//
//      if (aborted) {
//        return None
//      }
//    }
//
//    Some(result)
//  }
//}

/**
  * A basic service object
  */
trait PServiceStub {
  def start(context: Context, data: Node): OpResult[Unit]

  def stop(context: Context): Unit

  def readAttribute(node: Node, attributeName: String): String = {
    node.attribute(attributeName) match {
      case None => throw new IllegalStateException("Attribute " + attributeName + " not specified.")
      case Some(t) => t.toString()
    }
  }
  def readAttributeWDefault(node: Node, attributeName: String, default: String): String = {
    node.attribute(attributeName) match {
      case None => default
      case Some(t) => t.toString()
    }
  }
}

case object STOP_ACTOR_MODULE
case object ACTOR_STOPPED

abstract class BasicActorModule extends Module {
  var actor: LiftActor = _

  def createActor(): LiftActor

  /**
   * Called by the ModuleLoader at program startup so that the module can initialize its functional components
   * and register its services.
   *
   * @param context - the specific EFLContext within which this module will be operating.
   * @param data    - XML giving module specific initialization and configuration details.
   */
  override def start(context: Context, data: Node): OpResult[Unit] = {
    setName(data)

    actor = createActor()
    actor !! ((context, data), 2500) match {
      case Full(result: OpResult[Unit]) =>
        System.err.println("[BasicActorModule.start] initialization returned: " + result)
        result.continue match {
          case None => return OpResult.failure("Initialization should have completed.")
          case Some(true) => context.addService(name, actor)
          case Some(false) => // go ahead and return the failure
        }
        result
      case a =>
        System.err.println("[BasicActorModule.start] unexpected result: " + a)
        OpResult.failure("Unknown failure, initialization returned: " + a)
    }
  }

  /**
   * Called by the ModuleLoader at or just before program termination so that modules will be able to
   * write out unsaved data, free up resources, etc.
   *
   * @param context - the EFLContext this module has been running in.
   */
  override def stop(context: Context): Unit = {
    println("[stop] sending STOP_ACTOR_MODULE")
    actor !! (STOP_ACTOR_MODULE, 1000)
  }
}

/**
  * A common pattern we use is a module that creates a single service object
  * and registers it as a service for a particular context.
  *
  * @tparam T Type of the service object, extends the trait EFLServiceStub
  */
abstract class BasicModule[T <: PServiceStub] extends Module {
  var uiStuff: T = null.asInstanceOf[T]

  def createT(): T

  /**
    * Called by the ModuleLoader at program startup so that the module can initialize its functional components
    * and register its services.
    *
    * @param context - the specific EFLContext within which this module will be operating.
    * @param data    - XML giving module specific initialization and configuration details.
    */
  override def start(context: Context, data: Node): OpResult[Unit] = {
    setName(data)

    uiStuff = createT()
    val result = uiStuff.start(context, data)

    result.continue match {
      case None => OpResult.failure("Initialization should have completed.")
      case Some(true) => context.addService(name, uiStuff)
      case Some(false) => // return the failure result
    }

    result
  }

  def stop(context: Context): Unit ={
    context.removeService(uiStuff)
    uiStuff.stop(context)
    uiStuff = null.asInstanceOf[T]
  }
}

/**
 * Module that creates a single service that absolutely cannot be used in multiple
 * contexts.
 */
abstract class NonImportableBasicModule[T <: PServiceStub]  extends BasicModule[T] {
  def addContext(context: Context): Unit ={
    throw new RuntimeException("Multiple contexts not supported for '" + getClass.getName + "'.")
  }

  def removeContext(context: Context): Unit ={
    throw new RuntimeException("Multiple contexts not supported for '" + getClass.getName + "'.")
  }
}

/**
 * Modules that create a single service object that can be used in multiple contexts
 * and there are no special requirements for additional contexts.
 */
abstract class ImportableBasicModule[T <: PServiceStub]  extends BasicModule[T] {
  val contexts = new scala.collection.mutable.HashSet[Context]

  /**
    * Called by a context that wants to import this module from a parent module.
    *
    * @param context - the context that wishes to use this module's services
    */
  override def addContext(context: Context): Unit = {
    contexts.add(context)
    context.addService(uiStuff)
  }

  /**
    * Called by an importing context at shutdown
    *
    * @param context - the context that no longer needs this module's services
    */
  override def removeContext(context: Context): Unit = {
    contexts.remove(context)
    context.removeService(uiStuff)
  }
}
